

#include <vmm_error.h>
#include <vmm_compiler.h>
#include <vmm_spinlocks.h>
#include <vmm_stdio.h>
#include <vmm_clocksource.h>
#include <arch_timer.h>
#include <libs/stringlib.h>


struct vmm_clocksource_ctrl {
	vmm_spinlock_t lock;
	struct dlist clksrc_list;
	const struct vmm_devtree_nodeid *clksrc_matches;
};

static struct vmm_clocksource_ctrl csctrl;

#if defined(CONFIG_PROFILE)

u64 __notrace vmm_timecounter_read_for_profile(struct vmm_timecounter *tc)
{
	u64 cycles_now, cycles_delta;
	u64 ns_offset;

	if (!tc || !tc->cs) {
		return 0;
	}

	cycles_now = tc->cs->read(tc->cs);
	cycles_delta = (cycles_now - tc->cycles_last) & tc->cs->mask;
	ns_offset = vmm_clocksource_delta2nsecs(cycles_delta,
						tc->cs->mult, tc->cs->shift);

	return tc->nsec + ns_offset;
}
#endif

u64 vmm_timecounter_read(struct vmm_timecounter *tc)
{
	u64 cycles_now, cycles_delta;
	u64 ns_offset;

	if (!tc || !tc->cs) {
		return 0;
	}

	cycles_now = tc->cs->read(tc->cs);
	cycles_delta = (cycles_now - tc->cycles_last) & tc->cs->mask;
	tc->cycles_last = cycles_now;

	ns_offset = vmm_clocksource_delta2nsecs(cycles_delta,
						tc->cs->mult, tc->cs->shift);
	tc->nsec += ns_offset;

	return tc->nsec;
}

int vmm_timecounter_start(struct vmm_timecounter *tc)
{
	if (!tc || !tc->cs) {
		return VMM_EFAIL;
	}

	if (tc->cs->enable) {
		tc->cs->enable(tc->cs);
	}

	return VMM_OK;
}

int vmm_timecounter_stop(struct vmm_timecounter *tc)
{
	if (!tc || !tc->cs) {
		return VMM_EFAIL;
	}

	if (tc->cs->disable) {
		tc->cs->disable(tc->cs);
	}

	return VMM_OK;
}

int vmm_timecounter_init(struct vmm_timecounter *tc,
			 struct vmm_clocksource *cs,
			 u64 start_nsec)
{
	if (!tc || !cs) {
		return VMM_EFAIL;
	}

	tc->cs = cs;
	tc->cycles_last = cs->read(cs);
	tc->nsec = start_nsec;

	return VMM_OK;
}

int vmm_clocksource_register(struct vmm_clocksource *cs)
{
	bool found;
	irq_flags_t flags;
	struct vmm_clocksource *cst;

	if (!cs) {
		return VMM_EFAIL;
	}

	cst = NULL;
	found = FALSE;

	vmm_spin_lock_irqsave(&csctrl.lock, flags);

	list_for_each_entry(cst, &csctrl.clksrc_list, head) {
		if (strcmp(cst->name, cs->name) == 0) {
			found = TRUE;
			break;
		}
	}

	if (found) {
		vmm_spin_unlock_irqrestore(&csctrl.lock, flags);
		return VMM_EFAIL;
	}

	INIT_LIST_HEAD(&cs->head);
	list_add_tail(&cs->head, &csctrl.clksrc_list);

	vmm_spin_unlock_irqrestore(&csctrl.lock, flags);

	return VMM_OK;
}

int vmm_clocksource_unregister(struct vmm_clocksource *cs)
{
	bool found;
	irq_flags_t flags;
	struct vmm_clocksource *cst;

	if (!cs) {
		return VMM_EFAIL;
	}

	vmm_spin_lock_irqsave(&csctrl.lock, flags);

	if (list_empty(&csctrl.clksrc_list)) {
		vmm_spin_unlock_irqrestore(&csctrl.lock, flags);
		return VMM_EFAIL;
	}

	cst = NULL;
	found = FALSE;
	list_for_each_entry(cst, &csctrl.clksrc_list, head) {
		if (strcmp(cst->name, cs->name) == 0) {
			found = TRUE;
			break;
		}
	}

	if (!found) {
		vmm_spin_unlock_irqrestore(&csctrl.lock, flags);
		return VMM_ENOTAVAIL;
	}

	list_del(&cs->head);

	vmm_spin_unlock_irqrestore(&csctrl.lock, flags);

	return VMM_OK;
}

struct vmm_clocksource *vmm_clocksource_best(void)
{
	int rating = 0;
	irq_flags_t flags;
	struct vmm_clocksource *cs, *best_cs;

	cs = NULL;
	best_cs = NULL;

	vmm_spin_lock_irqsave(&csctrl.lock, flags);

	list_for_each_entry(cs, &csctrl.clksrc_list, head) {
		if (cs->rating > rating) {
			best_cs = cs;
			rating = cs->rating;
		}
	}

	vmm_spin_unlock_irqrestore(&csctrl.lock, flags);

	return best_cs;
}

struct vmm_clocksource *vmm_clocksource_find(const char *name)
{
	bool found;
	irq_flags_t flags;
	struct vmm_clocksource *cs;

	if (!name) {
		return NULL;
	}

	found = FALSE;
	cs = NULL;

	vmm_spin_lock_irqsave(&csctrl.lock, flags);

	list_for_each_entry(cs, &csctrl.clksrc_list, head) {
		if (strcmp(cs->name, name) == 0) {
			found = TRUE;
			break;
		}
	}

	vmm_spin_unlock_irqrestore(&csctrl.lock, flags);

	if (!found) {
		return NULL;
	}

	return cs;
}

struct vmm_clocksource *vmm_clocksource_get(int index)
{
	bool found;
	irq_flags_t flags;
	struct vmm_clocksource *cs;

	if (index < 0) {
		return NULL;
	}

	cs = NULL;
	found = FALSE;

	vmm_spin_lock_irqsave(&csctrl.lock, flags);

	list_for_each_entry(cs, &csctrl.clksrc_list, head) {
		if (!index) {
			found = TRUE;
			break;
		}
		index--;
	}

	vmm_spin_unlock_irqrestore(&csctrl.lock, flags);

	if (!found) {
		return NULL;
	}

	return cs;
}

u32 vmm_clocksource_count(void)
{
	u32 retval = 0;
	irq_flags_t flags;
	struct vmm_clocksource *cs;

	vmm_spin_lock_irqsave(&csctrl.lock, flags);

	list_for_each_entry(cs, &csctrl.clksrc_list, head) {
		retval++;
	}

	vmm_spin_unlock_irqrestore(&csctrl.lock, flags);

	return retval;
}

int __init __weak arch_clocksource_init(void)
{
	
	return VMM_OK;
}

static void __init clocksource_nidtbl_found(struct vmm_devtree_node *node,
					const struct vmm_devtree_nodeid *match,
					void *data)
{
	int err;
	vmm_clocksource_init_t init_fn = match->data;

	if (!init_fn) {
		return;
	}

	err = init_fn(node);
#ifdef CONFIG_VERBOSE_MODE
	if (err) {
		vmm_printf("%s: Init %s node failed (error %d)\n", 
			   __func__, node->name, err);
	}
#else
	(void)err;
#endif
}

int __init vmm_clocksource_init(void)
{
	int rc;

	
	INIT_SPIN_LOCK(&csctrl.lock);

	
	INIT_LIST_HEAD(&csctrl.clksrc_list);

	
	csctrl.clksrc_matches = 
		vmm_devtree_nidtbl_create_matches("clocksource");

	
	if ((rc = arch_clocksource_init())) {
		return rc;
	}

	
	if (csctrl.clksrc_matches) {
		vmm_devtree_iterate_matching(NULL,
					     csctrl.clksrc_matches,
					     clocksource_nidtbl_found,
					     NULL);
	}

	return VMM_OK;
}
