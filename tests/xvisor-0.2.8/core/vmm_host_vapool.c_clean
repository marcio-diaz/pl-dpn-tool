typedef int vmm_spinlock_t;typedef int u64;typedef int u16;typedef int bool;typedef int arch_regs_t;typedef int vmm_rwlock_t;typedef int resource_size_t;typedef int loff_t;typedef int irq_flags_t;typedef int u32;typedef int pthread_t;typedef int vmm_scheduler_ctrl;typedef int virtual_addr_t;typedef int u8;typedef int virtual_size_t;typedef int physical_addr_t;typedef int physical_size_t;typedef int atomic_t;typedef int vmm_iommu_fault_handler_t;typedef int dma_addr_t;typedef int size_t;typedef int off_t;typedef int vmm_dr_release_t;typedef int vmm_dr_match_t;typedef int vmm_clocksource_init_t;typedef int s64;typedef int va_list;typedef int vmm_host_irq_handler_t;typedef int vmm_host_irq_function_t;typedef int vmm_host_irq_init_t;typedef int Elf_Ehdr;typedef int Elf_Shdr;typedef int Elf_Sym;typedef int s16;typedef int vmm_clockchip_init_t;typedef int pthread_spinlock_t;



struct vmm_host_vapool_ctrl {
	virtual_addr_t vapool_start;
	virtual_size_t vapool_size;
	u32 vapool_page_count;
	struct buddy_allocator ba;
};

static struct vmm_host_vapool_ctrl vpctrl;

int vmm_host_vapool_alloc(virtual_addr_t *va, virtual_size_t sz)
{
	int rc;
	unsigned long addr;

	if (!va) {
		return VMM_EINVALID;
	}

	rc = buddy_mem_alloc(&vpctrl.ba, sz, &addr);
	if (!rc) {
		*va = addr;
	}

	return rc;
}

int vmm_host_vapool_reserve(virtual_addr_t va, virtual_size_t sz)
{
	if ((va < vpctrl.vapool_start) ||
	    ((vpctrl.vapool_start + vpctrl.vapool_size) < (va + sz))) {
		return VMM_EFAIL;
	}

	return buddy_mem_reserve(&vpctrl.ba, va, sz);
}

int vmm_host_vapool_find(virtual_addr_t va,
			 virtual_addr_t *alloc_va,
			 virtual_size_t *alloc_sz)
{
	int rc;
	unsigned long ava, asz;

	rc = buddy_mem_find(&vpctrl.ba, va, &ava, NULL, &asz);
	if (rc) {
		return rc;
	}

	if (alloc_va) {
		*alloc_va = ava;
	}
	if (alloc_sz) {
		*alloc_sz = asz;
	}

	return VMM_OK;
}

int vmm_host_vapool_free(virtual_addr_t va, virtual_size_t sz)
{
	if ((va < vpctrl.vapool_start) ||
	    ((vpctrl.vapool_start + vpctrl.vapool_size) < (va + sz))) {
		return VMM_EFAIL;
	}

	return buddy_mem_partial_free(&vpctrl.ba, va, sz);
}

bool vmm_host_vapool_page_isfree(virtual_addr_t va)
{
	bool ret = FALSE;

	if ((va < vpctrl.vapool_start) ||
	    ((vpctrl.vapool_start + vpctrl.vapool_size) <= va)) {
		return ret;
	}

	if (buddy_mem_find(&vpctrl.ba, va, NULL, NULL, NULL) != VMM_OK) {
		ret = TRUE;
	}

	return ret;
}

u32 vmm_host_vapool_free_page_count(void)
{
	return buddy_bins_free_space(&vpctrl.ba) >> VMM_PAGE_SHIFT;
}

u32 vmm_host_vapool_total_page_count(void)
{
	return vpctrl.vapool_page_count;
}

virtual_addr_t vmm_host_vapool_base(void)
{
	return vpctrl.vapool_start;
}

virtual_size_t vmm_host_vapool_size(void)
{
	return vpctrl.vapool_size;
}

bool vmm_host_vapool_isvalid(virtual_addr_t addr)
{
	if ((vpctrl.vapool_start <= addr) &&
	    (addr < (vpctrl.vapool_start + vpctrl.vapool_size))) {
		return TRUE;
	}
	return FALSE;
}

virtual_size_t vmm_host_vapool_estimate_hksize(virtual_size_t size)
{
	
	return size >> 8;
}

int vmm_host_vapool_print_state(struct vmm_chardev *cdev)
{
	unsigned long idx;

	vmm_cprintf(cdev, "VAPOOL State\n");

	for (idx = VAPOOL_MIN_BIN; idx <= VAPOOL_MAX_BIN; idx++) {
		if (idx < 10) {
			vmm_cprintf(cdev, "  [BLOCK %4dB]: ", 1<<idx);
		} else if (idx < 20) {
			vmm_cprintf(cdev, "  [BLOCK %4dK]: ", 1<<(idx-10));
		} else {
			vmm_cprintf(cdev, "  [BLOCK %4dM]: ", 1<<(idx-20));
		}
		vmm_cprintf(cdev, "%5lu area(s), %5lu free block(s)\n",
			    buddy_bins_area_count(&vpctrl.ba, idx),
			    buddy_bins_block_count(&vpctrl.ba, idx));
	}

	vmm_cprintf(cdev, "VAPOOL House-Keeping State\n");
	vmm_cprintf(cdev, "  Buddy Areas: %lu free out of %lu\n",
		    buddy_hk_area_free(&vpctrl.ba),
		    buddy_hk_area_total(&vpctrl.ba));

	return VMM_OK;
}

int  vmm_host_vapool_init(virtual_addr_t base,
				virtual_size_t size, 
				virtual_addr_t hkbase)
{
	int rc;

	if ((hkbase < base) || ((base + size) <= hkbase)) {
		return VMM_EFAIL;
	}

	vpctrl.vapool_start = base;
	vpctrl.vapool_size = size;
	vpctrl.vapool_start &= ~VMM_PAGE_MASK;
	vpctrl.vapool_size &= ~VMM_PAGE_MASK;
	vpctrl.vapool_page_count = vpctrl.vapool_size >> VMM_PAGE_SHIFT;

	rc = buddy_allocator_init(&vpctrl.ba, (void *)hkbase,
				  vmm_host_vapool_estimate_hksize(size),
				  base, size, VAPOOL_MIN_BIN, VAPOOL_MAX_BIN);
	if (rc) {
		return rc;
	}

	return VMM_OK;
}

