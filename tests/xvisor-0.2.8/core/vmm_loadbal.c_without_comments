

#include <vmm_error.h>
#include <vmm_timer.h>
#include <vmm_manager.h>
#include <vmm_threads.h>
#include <vmm_mutex.h>
#include <vmm_completion.h>
#include <vmm_loadbal.h>

#define LOADBAL_PRIORITY 		VMM_VCPU_DEF_PRIORITY
#define LOADBAL_TIMESLICE 		VMM_VCPU_DEF_TIME_SLICE
#define LOADBAL_PERIOD			(CONFIG_LOADBAL_PERIOD_SECS * 					 1000000000ULL)

struct vmm_loadbal_ctrl {
	struct vmm_mutex curr_algo_lock;
	struct vmm_loadbal_algo *curr_algo;
	struct vmm_mutex algo_list_lock;
	struct dlist algo_list;
	struct vmm_completion loadbal_cmpl;
	struct vmm_thread *loadbal_thread;
};

static bool lbctrl_init_done = FALSE;
static struct vmm_loadbal_ctrl lbctrl;

u32 vmm_loadbal_good_hcpu(u8 priority)
{
	u32 ret;

	if (!lbctrl_init_done ||
	    !vmm_timer_started() ||
	    (VMM_VCPU_MAX_PRIORITY < priority) ||
	    (priority < VMM_VCPU_MIN_PRIORITY) ||
	    (vmm_cpumask_weight(cpu_online_mask) < 2)) {
		return vmm_smp_processor_id();
	}

	vmm_mutex_lock(&lbctrl.curr_algo_lock);

	if (lbctrl.curr_algo && lbctrl.curr_algo->good_hcpu) {
		ret = lbctrl.curr_algo->good_hcpu(lbctrl.curr_algo, priority);
	} else {
		ret = vmm_smp_processor_id();
	}

	vmm_mutex_unlock(&lbctrl.curr_algo_lock);

	return ret;
}

static int loadbal_main(void *data)
{
	u64 tstamp;

	while (1) {
		tstamp = LOADBAL_PERIOD;
		vmm_completion_wait_timeout(&lbctrl.loadbal_cmpl, &tstamp);

		if (vmm_cpumask_weight(cpu_online_mask) < 2) {
			continue;
		}

		vmm_mutex_lock(&lbctrl.curr_algo_lock);

		if (lbctrl.curr_algo && lbctrl.curr_algo->balance) {
			lbctrl.curr_algo->balance(lbctrl.curr_algo);
		}

		vmm_mutex_unlock(&lbctrl.curr_algo_lock);
	}

	return VMM_OK;
}

struct vmm_loadbal_algo *vmm_loadbal_current_algo(void)
{
	struct vmm_loadbal_algo *ret;

	vmm_mutex_lock(&lbctrl.curr_algo_lock);
	ret = lbctrl.curr_algo;
	vmm_mutex_unlock(&lbctrl.curr_algo_lock);

	return ret;
}

static struct vmm_loadbal_algo *__loadbal_best_algo(void)
{
	u32 best_rating;
	struct vmm_loadbal_algo *algo, *best_algo;

	best_rating = 0;
	best_algo = NULL;
	list_for_each_entry(algo, &lbctrl.algo_list, head) {
		if (best_rating < algo->rating) {
			best_rating = algo->rating;
			best_algo = algo;
		}
	}

	return best_algo;
}

int vmm_loadbal_register_algo(struct vmm_loadbal_algo *lbalgo)
{
	int rc = VMM_OK;
	bool found;
	struct vmm_loadbal_algo *algo, *best_algo;

	
	if (!lbalgo) {
		return VMM_EFAIL;
	}

	
	vmm_mutex_lock(&lbctrl.algo_list_lock);

	
	found = FALSE;
	list_for_each_entry(algo, &lbctrl.algo_list, head) {
		if (algo == lbalgo) {
			found = TRUE;
			break;
		}
	}
	if (found) {
		vmm_mutex_unlock(&lbctrl.algo_list_lock);
		return VMM_EEXIST;
	}

	
	INIT_LIST_HEAD(&lbalgo->head);
	list_add_tail(&lbalgo->head, &lbctrl.algo_list);

	
	best_algo = __loadbal_best_algo();

	
	vmm_mutex_lock(&lbctrl.curr_algo_lock);
	if (best_algo && lbctrl.curr_algo != best_algo) {
		if (best_algo->start) {
			rc = best_algo->start(best_algo);
		}
		if (rc == VMM_OK) {
			if (lbctrl.curr_algo && lbctrl.curr_algo->stop) {
				lbctrl.curr_algo->stop(lbctrl.curr_algo);
			}
			lbctrl.curr_algo = best_algo;
		}
	}
	vmm_mutex_unlock(&lbctrl.curr_algo_lock);

	
	vmm_mutex_unlock(&lbctrl.algo_list_lock);

	return rc;
}

int vmm_loadbal_unregister_algo(struct vmm_loadbal_algo *lbalgo)
{
	int rc = VMM_OK;
	bool found;
	struct vmm_loadbal_algo *algo, *best_algo;

	
	if (!lbalgo || !lbalgo->balance) {
		return VMM_EFAIL;
	}

	
	vmm_mutex_lock(&lbctrl.algo_list_lock);

	
	found = FALSE;
	list_for_each_entry(algo, &lbctrl.algo_list, head) {
		if (algo == lbalgo) {
			found = TRUE;
			break;
		}
	}
	if (!found) {
		vmm_mutex_unlock(&lbctrl.algo_list_lock);
		return VMM_ENOTAVAIL;
	}

	
	vmm_mutex_lock(&lbctrl.curr_algo_lock);
	if (lbctrl.curr_algo == lbalgo) {
		if (lbctrl.curr_algo->stop) {
			lbctrl.curr_algo->stop(lbctrl.curr_algo);
		}
		lbctrl.curr_algo = NULL;
	}
	vmm_mutex_unlock(&lbctrl.curr_algo_lock);

	
	list_del(&lbalgo->head);

	
	best_algo = __loadbal_best_algo();

	
	vmm_mutex_lock(&lbctrl.curr_algo_lock);
	if (best_algo && lbctrl.curr_algo != best_algo) {
		if (best_algo->start) {
			rc = best_algo->start(best_algo);
		}
		if (rc == VMM_OK) {
			if (lbctrl.curr_algo && lbctrl.curr_algo->stop) {
				lbctrl.curr_algo->stop(lbctrl.curr_algo);
			}
			lbctrl.curr_algo = best_algo;
		}
	}
	vmm_mutex_unlock(&lbctrl.curr_algo_lock);

	
	vmm_mutex_unlock(&lbctrl.algo_list_lock);

	return rc;
}

int __init vmm_loadbal_init(void)
{
	int rc;

	
	INIT_MUTEX(&lbctrl.curr_algo_lock);
	lbctrl.curr_algo = NULL;

	
	INIT_MUTEX(&lbctrl.algo_list_lock);
	INIT_LIST_HEAD(&lbctrl.algo_list);

	
	INIT_COMPLETION(&lbctrl.loadbal_cmpl);

	
	lbctrl.loadbal_thread = vmm_threads_create("loadbal",
						   loadbal_main, NULL,
						   LOADBAL_PRIORITY,
						   LOADBAL_TIMESLICE);
	if (!lbctrl.loadbal_thread) {
		return VMM_EFAIL;
	}

	
	if ((rc = vmm_threads_set_affinity(lbctrl.loadbal_thread,
				vmm_cpumask_of(vmm_smp_processor_id())))) {
		return rc;
	}

	
	if ((rc = vmm_threads_start(lbctrl.loadbal_thread))) {
		return rc;
	}

	
	lbctrl_init_done = TRUE;

	return VMM_OK;
}

