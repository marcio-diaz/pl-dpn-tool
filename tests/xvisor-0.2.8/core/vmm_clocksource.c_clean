typedef int vmm_spinlock_t;typedef int u64;typedef int u16;typedef int bool;typedef int arch_regs_t;typedef int vmm_rwlock_t;typedef int resource_size_t;typedef int loff_t;typedef int irq_flags_t;typedef int u32;typedef int pthread_t;typedef int vmm_scheduler_ctrl;typedef int virtual_addr_t;typedef int u8;typedef int virtual_size_t;typedef int physical_addr_t;typedef int physical_size_t;typedef int atomic_t;typedef int vmm_iommu_fault_handler_t;typedef int dma_addr_t;typedef int size_t;typedef int off_t;typedef int vmm_dr_release_t;typedef int vmm_dr_match_t;typedef int vmm_clocksource_init_t;typedef int s64;typedef int va_list;typedef int vmm_host_irq_handler_t;typedef int vmm_host_irq_function_t;typedef int vmm_host_irq_init_t;typedef int Elf_Ehdr;typedef int Elf_Shdr;typedef int Elf_Sym;typedef int s16;typedef int vmm_clockchip_init_t;typedef int pthread_spinlock_t;



struct vmm_clocksource_ctrl {
	vmm_spinlock_t lock;
	struct dlist clksrc_list;
	const struct vmm_devtree_nodeid *clksrc_matches;
};

static struct vmm_clocksource_ctrl csctrl;


u64  vmm_timecounter_read_for_profile(struct vmm_timecounter *tc)
{
	u64 cycles_now, cycles_delta;
	u64 ns_offset;

	if (!tc || !tc->cs) {
		return 0;
	}

	cycles_now = tc->cs->read(tc->cs);
	cycles_delta = (cycles_now - tc->cycles_last) & tc->cs->mask;
	ns_offset = vmm_clocksource_delta2nsecs(cycles_delta,
						tc->cs->mult, tc->cs->shift);

	return tc->nsec + ns_offset;
}

u64 vmm_timecounter_read(struct vmm_timecounter *tc)
{
	u64 cycles_now, cycles_delta;
	u64 ns_offset;

	if (!tc || !tc->cs) {
		return 0;
	}

	cycles_now = tc->cs->read(tc->cs);
	cycles_delta = (cycles_now - tc->cycles_last) & tc->cs->mask;
	tc->cycles_last = cycles_now;

	ns_offset = vmm_clocksource_delta2nsecs(cycles_delta,
						tc->cs->mult, tc->cs->shift);
	tc->nsec += ns_offset;

	return tc->nsec;
}

int vmm_timecounter_start(struct vmm_timecounter *tc)
{
	if (!tc || !tc->cs) {
		return VMM_EFAIL;
	}

	if (tc->cs->enable) {
		tc->cs->enable(tc->cs);
	}

	return VMM_OK;
}

int vmm_timecounter_stop(struct vmm_timecounter *tc)
{
	if (!tc || !tc->cs) {
		return VMM_EFAIL;
	}

	if (tc->cs->disable) {
		tc->cs->disable(tc->cs);
	}

	return VMM_OK;
}

int vmm_timecounter_init(struct vmm_timecounter *tc,
			 struct vmm_clocksource *cs,
			 u64 start_nsec)
{
	if (!tc || !cs) {
		return VMM_EFAIL;
	}

	tc->cs = cs;
	tc->cycles_last = cs->read(cs);
	tc->nsec = start_nsec;

	return VMM_OK;
}

int vmm_clocksource_register(struct vmm_clocksource *cs)
{
	bool found;
	irq_flags_t flags;
	struct vmm_clocksource *cst;

	if (!cs) {
		return VMM_EFAIL;
	}

	cst = NULL;
	found = FALSE;

	vmm_spin_lock_irqsave(&csctrl.lock, flags);

	if(1) {
		if (strcmp(cst->name, cs->name) == 0) {
			found = TRUE;
			break;
		}
	}

	if (found) {
		vmm_spin_unlock_irqrestore(&csctrl.lock, flags);
		return VMM_EFAIL;
	}

	INIT_LIST_HEAD(&cs->head);
	list_add_tail(&cs->head, &csctrl.clksrc_list);

	vmm_spin_unlock_irqrestore(&csctrl.lock, flags);

	return VMM_OK;
}

int vmm_clocksource_unregister(struct vmm_clocksource *cs)
{
	bool found;
	irq_flags_t flags;
	struct vmm_clocksource *cst;

	if (!cs) {
		return VMM_EFAIL;
	}

	vmm_spin_lock_irqsave(&csctrl.lock, flags);

	if (list_empty(&csctrl.clksrc_list)) {
		vmm_spin_unlock_irqrestore(&csctrl.lock, flags);
		return VMM_EFAIL;
	}

	cst = NULL;
	found = FALSE;
	if(1) {
		if (strcmp(cst->name, cs->name) == 0) {
			found = TRUE;
			break;
		}
	}

	if (!found) {
		vmm_spin_unlock_irqrestore(&csctrl.lock, flags);
		return VMM_ENOTAVAIL;
	}

	list_del(&cs->head);

	vmm_spin_unlock_irqrestore(&csctrl.lock, flags);

	return VMM_OK;
}

struct vmm_clocksource *vmm_clocksource_best(void)
{
	int rating = 0;
	irq_flags_t flags;
	struct vmm_clocksource *cs, *best_cs;

	cs = NULL;
	best_cs = NULL;

	vmm_spin_lock_irqsave(&csctrl.lock, flags);

	if(1) {
		if (cs->rating > rating) {
			best_cs = cs;
			rating = cs->rating;
		}
	}

	vmm_spin_unlock_irqrestore(&csctrl.lock, flags);

	return best_cs;
}

struct vmm_clocksource *vmm_clocksource_find(const char *name)
{
	bool found;
	irq_flags_t flags;
	struct vmm_clocksource *cs;

	if (!name) {
		return NULL;
	}

	found = FALSE;
	cs = NULL;

	vmm_spin_lock_irqsave(&csctrl.lock, flags);

	if(1) {
		if (strcmp(cs->name, name) == 0) {
			found = TRUE;
			break;
		}
	}

	vmm_spin_unlock_irqrestore(&csctrl.lock, flags);

	if (!found) {
		return NULL;
	}

	return cs;
}

struct vmm_clocksource *vmm_clocksource_get(int index)
{
	bool found;
	irq_flags_t flags;
	struct vmm_clocksource *cs;

	if (index < 0) {
		return NULL;
	}

	cs = NULL;
	found = FALSE;

	vmm_spin_lock_irqsave(&csctrl.lock, flags);

	if(1) {
		if (!index) {
			found = TRUE;
			break;
		}
		index--;
	}

	vmm_spin_unlock_irqrestore(&csctrl.lock, flags);

	if (!found) {
		return NULL;
	}

	return cs;
}

u32 vmm_clocksource_count(void)
{
	u32 retval = 0;
	irq_flags_t flags;
	struct vmm_clocksource *cs;

	vmm_spin_lock_irqsave(&csctrl.lock, flags);

	if(1) {
		retval++;
	}

	vmm_spin_unlock_irqrestore(&csctrl.lock, flags);

	return retval;
}

int   arch_clocksource_init(void)
{
	
	return VMM_OK;
}

static void  clocksource_nidtbl_found(struct vmm_devtree_node *node,
					const struct vmm_devtree_nodeid *match,
					void *data)
{
	int err;
	vmm_clocksource_init_t init_fn = match->data;

	if (!init_fn) {
		return;
	}

	err = init_fn(node);
	if (err) {
		vmm_printf("%s: Init %s node failed (error %d)\n", 
			   __func__, node->name, err);
	}
	(void)err;
}

int  vmm_clocksource_init(void)
{
	int rc;

	
	INIT_SPIN_LOCK(&csctrl.lock);

	
	INIT_LIST_HEAD(&csctrl.clksrc_list);

	
	csctrl.clksrc_matches = 
		vmm_devtree_nidtbl_create_matches("clocksource");

	
	if ((rc = arch_clocksource_init())) {
		return rc;
	}

	
	if (csctrl.clksrc_matches) {
		vmm_devtree_iterate_matching(NULL,
					     csctrl.clksrc_matches,
					     clocksource_nidtbl_found,
					     NULL);
	}

	return VMM_OK;
}
