typedef int vmm_spinlock_t;typedef int u64;typedef int u16;typedef int bool;typedef int arch_regs_t;typedef int vmm_rwlock_t;typedef int resource_size_t;typedef int loff_t;typedef int irq_flags_t;typedef int u32;typedef int pthread_t;typedef int vmm_scheduler_ctrl;typedef int virtual_addr_t;typedef int u8;typedef int virtual_size_t;typedef int physical_addr_t;typedef int physical_size_t;typedef int atomic_t;typedef int vmm_iommu_fault_handler_t;typedef int dma_addr_t;typedef int size_t;typedef int off_t;typedef int vmm_dr_release_t;typedef int vmm_dr_match_t;typedef int vmm_clocksource_init_t;typedef int s64;typedef int va_list;typedef int vmm_host_irq_handler_t;typedef int vmm_host_irq_function_t;typedef int vmm_host_irq_init_t;typedef int Elf_Ehdr;typedef int Elf_Shdr;typedef int Elf_Sym;typedef int s16;typedef int vmm_clockchip_init_t;typedef int pthread_spinlock_t;


struct vmm_wallclock_ctrl {
	vmm_spinlock_t lock;
	struct vmm_timeval tv;
	struct vmm_timezone tz;
	u64 last_modify_tstamp;
};

static struct vmm_wallclock_ctrl wclk;

void vmm_timeval_set_normalized(struct vmm_timeval *tv, s64 sec, s64 nsec)
{
	while (nsec >= NSEC_PER_SEC) {
		
		nsec -= NSEC_PER_SEC;
		++sec;
	}
	while (nsec < 0) {
		nsec += NSEC_PER_SEC;
		--sec;
	}
	tv->tv_sec = sec;
	tv->tv_nsec = nsec;
}

struct vmm_timeval vmm_timeval_add(struct vmm_timeval lhs,
				   struct vmm_timeval rhs)
{
	struct vmm_timeval tv_delta;
	vmm_timeval_set_normalized(&tv_delta, lhs.tv_sec + rhs.tv_sec,
				   lhs.tv_nsec + rhs.tv_nsec);
	if (tv_delta.tv_sec < lhs.tv_sec || tv_delta.tv_sec < rhs.tv_sec)
		tv_delta.tv_sec = VMM_TIMEVAL_SEC_MAX;
	return tv_delta;
}

struct vmm_timeval vmm_timeval_sub(struct vmm_timeval lhs,
				   struct vmm_timeval rhs)
{
	struct vmm_timeval tv_delta;
	vmm_timeval_set_normalized(&tv_delta, lhs.tv_sec - rhs.tv_sec,
				   lhs.tv_nsec - rhs.tv_nsec);
	if (tv_delta.tv_sec < lhs.tv_sec || tv_delta.tv_sec < rhs.tv_sec)
		tv_delta.tv_sec = VMM_TIMEVAL_SEC_MAX;
	return tv_delta;
}

struct vmm_timeval vmm_ns_to_timeval(const s64 nsec)
{
	struct vmm_timeval tv;

	if (!nsec) {
		tv.tv_sec = 0;
		tv.tv_nsec = 0;
		return tv;
	}

	tv.tv_sec = sdiv64(nsec, NSEC_PER_SEC);
	tv.tv_nsec = nsec - tv.tv_sec * NSEC_PER_SEC;
	if (tv.tv_nsec < 0) {
		tv.tv_sec--;
		tv.tv_nsec += NSEC_PER_SEC;
	}

	return tv;
}


static int __isleap(long year)
{
	return (year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0);
}


static long math_div(long a, long b)
{
	return sdiv64(a, b) - (smod64(a, b) < 0);
}


static long leaps_between(long y1, long y2)
{
	long leaps1 = math_div(y1 - 1, 4) - math_div(y1 - 1, 100)
		+ math_div(y1 - 1, 400);
	long leaps2 = math_div(y2 - 1, 4) - math_div(y2 - 1, 100)
		+ math_div(y2 - 1, 400);
	return leaps2 - leaps1;
}


static const unsigned short __mon_yday[2][13] = {
	
	{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},
	
	{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}
};


void vmm_wallclock_mkinfo(s64 totalsecs, int offset, 
			  struct vmm_timeinfo *result)
{
	long days, rem, y;
	const unsigned short *ip;

	days = sdiv64(totalsecs, SECS_PER_DAY);
	rem = totalsecs - days * SECS_PER_DAY;
	rem += offset;
	while (rem < 0) {
		rem += SECS_PER_DAY;
		--days;
	}
	while (rem >= SECS_PER_DAY) {
		rem -= SECS_PER_DAY;
		++days;
	}

	result->tm_hour = rem / SECS_PER_HOUR;
	rem %= SECS_PER_HOUR;
	result->tm_min = rem / 60;
	result->tm_sec = rem % 60;

	
	result->tm_wday = (4 + days) % 7;
	if (result->tm_wday < 0)
		result->tm_wday += 7;

	y = 1970;

	while (days < 0 || days >= (__isleap(y) ? 366 : 365)) {
		
		long yg = y + math_div(days, 365);

		
		days -= (yg - y) * 365 + leaps_between(y, yg);
		y = yg;
	}

	result->tm_year = y - 1900;

	result->tm_yday = days;

	ip = __mon_yday[__isleap(y)];
	for (y = 11; days < ip[y]; y--)
		continue;
	days -= ip[y];

	result->tm_mon = y;
	result->tm_mday = days + 1;
}


s64 vmm_wallclock_mktime(const unsigned int year0, 
			 const unsigned int mon0,
			 const unsigned int day, 
			 const unsigned int hour,
			 const unsigned int min, 
			 const unsigned int sec)
{
	unsigned int year = year0, mon = mon0;
	u64 ret;

	
	if (0 >= (int) (mon -= 2)) {
		mon += 12; 
		year -= 1;
	}

	
	ret = (u64)(year/4 - year/100 + year/400 + 367*mon/12 + day);
	ret += (u64)(year)*365 - 719499;

	
	ret *= (u64)24;
	ret += hour;
	
	
	ret *= (u64)60;
	ret += min;

	
	ret *= (u64)60;
	ret += sec;

	return (s64)ret;
}

int vmm_wallclock_set_local_time(struct vmm_timeval *tv)
{
	irq_flags_t flags;

	if (!tv) {
		return VMM_EFAIL;
	}

	vmm_spin_lock_irqsave(&wclk.lock, flags);

	wclk.tv.tv_sec = tv->tv_sec;
	wclk.tv.tv_nsec = tv->tv_nsec;
	wclk.last_modify_tstamp = vmm_timer_timestamp();

	vmm_spin_unlock_irqrestore(&wclk.lock, flags);

	return VMM_OK;
}

int vmm_wallclock_get_local_time(struct vmm_timeval *tv)
{
	irq_flags_t flags;
	u64 tdiff, tdiv, tmod;

	if (!tv) {
		return VMM_EFAIL;
	}

	vmm_spin_lock_irqsave(&wclk.lock, flags);

	tv->tv_sec = wclk.tv.tv_sec;
	tv->tv_nsec = wclk.tv.tv_nsec;
	tdiff = vmm_timer_timestamp() - wclk.last_modify_tstamp;

	vmm_spin_unlock_irqrestore(&wclk.lock, flags);

	tdiv = udiv64(tdiff, NSEC_PER_SEC);
	tmod = tdiff - tdiv * NSEC_PER_SEC;
	tv->tv_nsec += tmod;
	while (NSEC_PER_SEC <= tv->tv_nsec) {
		tv->tv_sec++;
		tv->tv_nsec -= NSEC_PER_SEC;
	}
	tv->tv_sec += tdiv;

	return VMM_OK;
}

int vmm_wallclock_set_timezone(struct vmm_timezone *tz)
{
	int minuteswest;
	irq_flags_t flags;

	if (!tz) {
		return VMM_EFAIL;
	}

	vmm_spin_lock_irqsave(&wclk.lock, flags);

	minuteswest = tz->tz_minuteswest - wclk.tz.tz_minuteswest;
	wclk.tv.tv_sec += minuteswest * 60;
	wclk.tz.tz_minuteswest = tz->tz_minuteswest;
	wclk.tz.tz_dsttime = tz->tz_dsttime;

	vmm_spin_unlock_irqrestore(&wclk.lock, flags);

	return VMM_OK;
}

int vmm_wallclock_get_timezone(struct vmm_timezone *tz)
{
	irq_flags_t flags;

	if (!tz) {
		return VMM_EFAIL;
	}

	vmm_spin_lock_irqsave(&wclk.lock, flags);

	tz->tz_minuteswest = wclk.tz.tz_minuteswest;
	tz->tz_dsttime = wclk.tz.tz_dsttime;

	vmm_spin_unlock_irqrestore(&wclk.lock, flags);

	return VMM_OK;
}

int vmm_wallclock_set_timeofday(struct vmm_timeval *tv, 
				struct vmm_timezone *tz)
{
	int rc;

	if (tz) {
		if ((rc = vmm_wallclock_set_timezone(tz))) {
			return rc;
		}
	}

	if (tv) {
		if ((rc = vmm_wallclock_set_local_time(tv))) {
			return rc;
		}
	}

	return VMM_OK;
}

int vmm_wallclock_get_timeofday(struct vmm_timeval *tv, 
				struct vmm_timezone *tz)
{
	int rc;

	if (tz) {
		if ((rc = vmm_wallclock_get_timezone(tz))) {
			return rc;
		}
	}

	if (tv) {
		if ((rc = vmm_wallclock_get_local_time(tv))) {
			return rc;
		}
	}

	return VMM_OK;
}

int vmm_wallclock_init(void)
{
	memset(&wclk, 0, sizeof(wclk));

	INIT_SPIN_LOCK(&wclk.lock);

	wclk.tv.tv_sec = 0;
	wclk.tv.tv_nsec = 0;

	wclk.tz.tz_minuteswest = 0;
	wclk.tz.tz_dsttime = 0;

	wclk.last_modify_tstamp = vmm_timer_timestamp();

	return VMM_OK;
}

