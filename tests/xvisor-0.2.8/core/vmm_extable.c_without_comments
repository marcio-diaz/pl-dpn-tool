

#include <vmm_error.h>
#include <vmm_stdio.h>
#include <vmm_cpumask.h>
#include <vmm_host_aspace.h>
#include <vmm_percpu.h>
#include <vmm_extable.h>
#include <libs/libsort.h>
#include <arch_config.h>
#include <arch_sections.h>

#ifdef ARCH_HAS_EXTABLE


static int cmp_ex(const void *a, const void *b)
{
	const struct vmm_extable_entry *x = a, *y = b;

	
	if (x->insn > y->insn)
		return 1;
	if (x->insn < y->insn)
		return -1;
	return 0;
}

static void sort_extable(struct vmm_extable_entry *start,
			 struct vmm_extable_entry *finish)
{
	simple_sort(start, finish - start,
		    sizeof(struct vmm_extable_entry),
		    cmp_ex, NULL);
}


static const struct vmm_extable_entry *
search_extable(const struct vmm_extable_entry *first,
		const struct vmm_extable_entry *last,
		unsigned long value)
{
	while (first <= last) {
		const struct vmm_extable_entry *mid;

		mid = ((last - first) >> 1) + first;
		
		if (mid->insn < value)
			first = mid + 1;
		else if (mid->insn > value)
			last = mid - 1;
		else
			return mid;
	}

	return NULL;
}

const struct vmm_extable_entry *vmm_extable_search(unsigned long addr)
{
	struct vmm_extable_entry *start =
			(struct vmm_extable_entry *)arch_extable_start();
	struct vmm_extable_entry *end =
			(struct vmm_extable_entry *)arch_extable_end();
	const struct vmm_extable_entry *e;

	e = search_extable(start, end-1, addr);

	return e;
}

int __init vmm_extable_init(void)
{
	struct vmm_extable_entry *start =
			(struct vmm_extable_entry *)arch_extable_start();
	struct vmm_extable_entry *end =
			(struct vmm_extable_entry *)arch_extable_end();

	
	sort_extable(start, end);

	return VMM_OK;
}

#else

const struct vmm_extable_entry *vmm_extable_search(unsigned long addr)
{
	return NULL;
}

int __init vmm_extable_init(void)
{
	
	return VMM_OK;
}

#endif
